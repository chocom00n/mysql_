/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package omjdbc.base;

import java.awt.Color;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.rowset.*;
import javax.swing.DefaultListModel;
import javax.swing.JOptionPane;
import javax.swing.UIManager;

/**
 *
 * @author zaurak (OMDB) le 08.04.2018 exemple pour nos apprentis informaticiens
 * aussi brillants que "zaurak" J'ai laissé les commentaires générés
 * automatiquement par NETBEANS
 *
 * Affichage de 3 tables provenant d'une base de données de gestion des libellés
 * de problèmes (Physique, Maths, Histoire, etc) bref toutes les questions qu'un
 * prof peut poser aux élèves pour les faire transpirer par pure humiliation. Un
 * libellé est un "amas" de mots avec un point d'interrogation à la fin.
 *
 * Un être simple peut penser que cette définition correspond à une question....
 * mais il s'agit de traiter par la suite des libellés contenant plusieurs
 * questions, donc je ne pouvais pas confondre la notion de libellé avec la
 * notion de questions Bref.... ce n'est pas important ici...
 *
 *
 * Il s'agit d'afficher les catégories des libellés. Il peut y avoir plusieurs
 * catégories pour un libellé. Il s'agit d'afficher les sous catégories des
 * libellés. Il peut y avoir plusieurs sous catégories pour un libellé.
 *
 */
public class ClaGestionLibellesCatSousCat extends javax.swing.JDialog {

    public PreparedStatement pstsf;
    public ResultSet rssf;
    public PreparedStatement pstScCat;
    public ResultSet rsScCat;
    private List<String> selectedValuesSousCategories;
    private List<String> selectedValuesCategories;
    private ClaConnectionBd oConnection = new ClaConnectionBd();
    private RowSetFactory factory;
    private CachedRowSet rowset;
    private ClaSelectJlistSousCategories selectScJlist;
    private ClaSelectJlistCategories selectCatJlist;
    private String idLibProbSendSelecJlist;
    private String idLibProb;

    /**
     * Creates new form essaiJList
     *
     * @throws java.sql.SQLException
     */
    public ClaGestionLibellesCatSousCat() {

        initComponents(); // OMDB 08.04.2018 : NETBEANS écrit automatiquement cet appel initComponents()
        selectScJlist = new ClaSelectJlistSousCategories();
        selectCatJlist = new ClaSelectJlistCategories();

        // OMDB 29.04.2018 : Empêche de sélectionner une autre fenêtre tant que celle-ci n'est pas ferméee
        //this.setModal(true);
        // OMDB 08.04.2018 : Donne un titre très clair à la petite fenêtre de consultation.. mais pas d'édition...
        setTitle("Affichage des libellés");
        // OMDB 08.04.2018 : Les longs textes sont automatiquement formattés pour être dans le jTextArea
        jTextArea1Libelle.setLineWrap(true);
        // OMDB 08.04.2018 : Ne pas laisser l'utilisateur modifier ou sélectionner le texte du libellé.        
        jTextArea1Libelle.setEnabled(false);
        // OMDB 08.04.2018 : Change la couleur d'affichage du texte pour qu'il soit en "BLACK" plutôt qu'en LIGHT_GRAY.
        jTextArea1Libelle.setDisabledTextColor(Color.BLACK);

        // OMDB 16.04.2018 : Ne pas laisser l'utilisateur effacer sans avoir sélectionner des sous catégories
        jButton1EffacerSCLibelle.setEnabled(false);
        // OMDB 24.04.2018 : Ne pas laisser l'utilisateur effacer sans avoir sélectionner des catégories
        jButton1EffacerCategorie.setEnabled(false);
        // OMDB 08.04.2018 : Laisser l'utilisateur sélectionner les éléments de la jList des sous catégories.
        jList1SousCategories.setEnabled(true);
        // OMDB 08.04.2018 : La magie du JAVA (quel cirque !!!) pour que la couleur d'affichage des éléments de la liste soit en "BLACK" plutôt qu'en LIGHT_GRAY.
        // on change la couleur par défaut de l'interface utilisateur
        // il y a peut-être plus simple... mais bon... allez-y cherchez !!!!        
        UIManager.put("Label.disabledForeground", Color.BLACK);

        requete_id_libelle();

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jList1SousCategories = new javax.swing.JList<>();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea1Libelle = new javax.swing.JTextArea();
        jLabel1_Libelle = new javax.swing.JLabel();
        jLabel1_SousCategories = new javax.swing.JLabel();
        jButton1FirstRecord = new javax.swing.JButton();
        jButton1Fermer = new javax.swing.JButton();
        jButton1NextRecord = new javax.swing.JButton();
        jButton1PrevRecord = new javax.swing.JButton();
        jButton1LastRecord = new javax.swing.JButton();
        jLabel2MessageNavigation = new javax.swing.JLabel();
        jLabel1idLibelle = new javax.swing.JLabel();
        jLabel1Categories = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jList1Categories = new javax.swing.JList<>();
        jButton1AjouterSCLibelle = new javax.swing.JButton();
        jButton1EffacerSCLibelle = new javax.swing.JButton();
        jButton1AjouterCategorie = new javax.swing.JButton();
        jButton1EffacerCategorie = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowActivated(java.awt.event.WindowEvent evt) {
                formWindowActivated(evt);
            }
        });

        jList1SousCategories.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { "Item 1", "Item 2" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        jList1SousCategories.setSelectionForeground(new java.awt.Color(153, 51, 255));
        jList1SousCategories.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                jList1SousCategoriesValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(jList1SousCategories);

        jTextArea1Libelle.setColumns(20);
        jTextArea1Libelle.setLineWrap(true);
        jTextArea1Libelle.setRows(5);
        jTextArea1Libelle.setDisabledTextColor(new java.awt.Color(255, 0, 51));
        jTextArea1Libelle.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTextArea1LibelleMouseClicked(evt);
            }
        });
        jScrollPane2.setViewportView(jTextArea1Libelle);

        jLabel1_Libelle.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel1_Libelle.setText("Libellé");

        jLabel1_SousCategories.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel1_SousCategories.setText("Sous catégories");

        jButton1FirstRecord.setText("|<");
        jButton1FirstRecord.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1FirstRecordActionPerformed(evt);
            }
        });

        jButton1Fermer.setText("FERMER");
        jButton1Fermer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1FermerActionPerformed(evt);
            }
        });

        jButton1NextRecord.setText(">");
        jButton1NextRecord.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1NextRecordActionPerformed(evt);
            }
        });

        jButton1PrevRecord.setText("<");
        jButton1PrevRecord.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1PrevRecordActionPerformed(evt);
            }
        });

        jButton1LastRecord.setText(">|");
        jButton1LastRecord.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1LastRecordActionPerformed(evt);
            }
        });

        jLabel2MessageNavigation.setAutoscrolls(true);

        jLabel1idLibelle.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N

        jLabel1Categories.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel1Categories.setText("Catégories");

        jList1Categories.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        jList1Categories.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                jList1CategoriesValueChanged(evt);
            }
        });
        jScrollPane3.setViewportView(jList1Categories);

        jButton1AjouterSCLibelle.setText("Ajouter sous catégories");
        jButton1AjouterSCLibelle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1AjouterSCLibelleActionPerformed(evt);
            }
        });

        jButton1EffacerSCLibelle.setText("Effacer sous catégories");
        jButton1EffacerSCLibelle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1EffacerSCLibelleActionPerformed(evt);
            }
        });

        jButton1AjouterCategorie.setText("Ajouter catégories");
        jButton1AjouterCategorie.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1AjouterCategorieActionPerformed(evt);
            }
        });

        jButton1EffacerCategorie.setText("Effacer catégories");
        jButton1EffacerCategorie.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1EffacerCategorieActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton1Fermer)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 275, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1_Libelle)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(18, 18, 18)
                                        .addComponent(jLabel1idLibelle))
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(jLabel2MessageNavigation))))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jButton1FirstRecord)
                                .addGap(16, 16, 16)
                                .addComponent(jButton1PrevRecord)
                                .addGap(18, 18, 18)
                                .addComponent(jButton1NextRecord)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jButton1LastRecord)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel1Categories)
                            .addComponent(jButton1AjouterCategorie, javax.swing.GroupLayout.DEFAULT_SIZE, 255, Short.MAX_VALUE)
                            .addComponent(jButton1EffacerCategorie, javax.swing.GroupLayout.DEFAULT_SIZE, 255, Short.MAX_VALUE)
                            .addComponent(jScrollPane3))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(jLabel1_SousCategories)
                                .addComponent(jButton1AjouterSCLibelle, javax.swing.GroupLayout.PREFERRED_SIZE, 255, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 255, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jButton1EffacerSCLibelle, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 255, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1_Libelle)
                            .addComponent(jLabel2MessageNavigation)
                            .addComponent(jLabel1idLibelle)
                            .addComponent(jLabel1Categories))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 208, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jButton1FirstRecord)
                                    .addComponent(jButton1NextRecord)
                                    .addComponent(jButton1LastRecord)
                                    .addComponent(jButton1PrevRecord)))
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 300, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1AjouterCategorie, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1EffacerCategorie))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1_SousCategories)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 459, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1AjouterSCLibelle, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1EffacerSCLibelle)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 165, Short.MAX_VALUE)
                .addComponent(jButton1Fermer)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1FirstRecordActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1FirstRecordActionPerformed
        // TODO add your handling code here:
//        jButton1EffacerSCLibelle.setEnabled(false);
        //jButton1EffacerCategorie.setEnabled(false);

        // OMDB 04.04.2018 : Affiche le premier libellé avec le(s) sous catégorie(s) qui correspond(ent).
        remplir_listes_categories_sous_categories("FIRST", rowset);
    }//GEN-LAST:event_jButton1FirstRecordActionPerformed

    private void jButton1FermerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1FermerActionPerformed
        // TODO add your handling code here:

        try {
            if (pstScCat.isClosed()) {
                System.out.println("pstScCat est fermé");
            } else {
                System.out.println("pstScCat est ouvert");
                /* OMDB 09.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                    AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
                 */
                oConnection.closeConnection();
            }

        } catch (SQLException ex) {
            Logger.getLogger(ClaGestionLibellesCatSousCat.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                /* OMDB 09.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                    AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
                 */
                oConnection.closeConnection();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        // OMDB 07.04.2018 : Ferme la fenêtre actuelle.
        this.dispose();

    }//GEN-LAST:event_jButton1FermerActionPerformed

    private void jButton1NextRecordActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1NextRecordActionPerformed
        // TODO add your handling code here:
        // OMDB 04.04.2018 : Affiche le libellé suivant avec le(s) sous catégorie(s) qui correspond(ent).
        remplir_listes_categories_sous_categories("NEXT", rowset);
    }//GEN-LAST:event_jButton1NextRecordActionPerformed

    private void jButton1PrevRecordActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1PrevRecordActionPerformed
        // TODO add your handling code here:
        // OMDB 04.04.2018 : Affiche le libellé précédent avec le(s) sous catégorie(s) qui correspond(ent).
        remplir_listes_categories_sous_categories("PREV", rowset);
    }//GEN-LAST:event_jButton1PrevRecordActionPerformed

    private void jButton1LastRecordActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1LastRecordActionPerformed
        // TODO add your handling code here:
        // OMDB 04.04.2018 : Affiche le dernier libellé avec le(s) sous catégorie(s) qui correspond(ent).
        remplir_listes_categories_sous_categories("LAST", rowset);
    }//GEN-LAST:event_jButton1LastRecordActionPerformed

    private void jTextArea1LibelleMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTextArea1LibelleMouseClicked
        // TODO add your handling code here:
        // OMDB 08.04.2018 : Affiche le message en rouge pour rappeler à l'utilisateur qu'on ne peut que consulter la fenêtre et pas "manipuler" les données.        
        jLabel2MessageNavigation.setForeground(Color.RED);
        jLabel2MessageNavigation.setText("Pas d'édition. Hihi !");
    }//GEN-LAST:event_jTextArea1LibelleMouseClicked

    private void jButton1AjouterSCLibelleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1AjouterSCLibelleActionPerformed
        // TODO add your handling code here:
        // OMDB 11.04.2018 : Si le formulaire est ouvert on désactive le bouton, pour empêcher qu'il s'ouvre plus d'une fois
        idLibProbSendSelecJlist = this.jLabel1idLibelle.getText();
        int intidLibProbSendSelecJlist = Integer.parseInt(idLibProbSendSelecJlist);

        // OMDB 11.04.2018 : Passer l'id libellé à une autre classe (fenêtre
        ClaSelectJlistSousCategories frame2 = new ClaSelectJlistSousCategories(intidLibProbSendSelecJlist);
        frame2.setVisible(false);

        if (selectScJlist.isVisible()) {
            jButton1AjouterSCLibelle.setEnabled(false);
        } else {
            // OMDB 02.04.2018 : "Affichage" du formulaire.
            selectScJlist.setVisible(true);

            /* OMDB 11.04.2018 : Désactiver le bouton d'affichage du formulaire, pour empêcher d'ouvrir le même formulaire plusieurs fois.
                    on le réactive à la fermeture du formulaire
             */
            jButton1AjouterSCLibelle.setEnabled(false);
        }
    }//GEN-LAST:event_jButton1AjouterSCLibelleActionPerformed


    private void formWindowActivated(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowActivated
        // TODO add your handling code here:
        /* OMDB 11.04.2018 : Rafraîchir les 2 listes car il y a eu un changement, soit en insertion, soit un effacement dans une des listes
         */
        remplir_listes_categories_sous_categories("ACTUAL", rowset);
        // OMDB 11.04.2018 : Autoriser l'ajout dans les listes grâce aux boutons AJOUT
        jButton1AjouterSCLibelle.setEnabled(true);
        jButton1AjouterCategorie.setEnabled(true);
    }//GEN-LAST:event_formWindowActivated

    private void jList1SousCategoriesValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_jList1SousCategoriesValueChanged
        // TODO add your handling code here:
        // OMDB 13.04.2018 : Affiche les valeurs sélectionnées par l'utilisateur.
        if (!evt.getValueIsAdjusting()) {
            jButton1EffacerSCLibelle.setEnabled(true);
            selectedValuesSousCategories = (List<String>) jList1SousCategories.getSelectedValuesList();
            // OMDB 13.04.2018 : Affiche dans une fenêtre jTextArea1SCselected les sous catégories sélectionnées
            String chaineselectedValuesSousCategories = String.join("\n", selectedValuesSousCategories);
        } else {
            jButton1EffacerSCLibelle.setEnabled(false);
        }
    }//GEN-LAST:event_jList1SousCategoriesValueChanged

    private void jButton1EffacerSCLibelleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1EffacerSCLibelleActionPerformed
        // TODO add your handling code here:
        // OMDB 13.04.2018 : Efface les sous catégories sélectionnées
        effacerLibelleSousCategorieBD();
    }//GEN-LAST:event_jButton1EffacerSCLibelleActionPerformed

    private void jButton1AjouterCategorieActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1AjouterCategorieActionPerformed
        // TODO add your handling code here:

        idLibProbSendSelecJlist = this.jLabel1idLibelle.getText();
        int intidLibProbSendSelecJlist = Integer.parseInt(idLibProbSendSelecJlist);

        /*
            OMDB 28.04.2018 : On ouvre la fenêtre de sélection pour ajouter des catégories, avec un passage en paramètre de l'id libelle actuel
         */
        ClaSelectJlistCategories frameCategorie = new ClaSelectJlistCategories(intidLibProbSendSelecJlist);
        frameCategorie.setVisible(false);

        // OMDB 11.04.2018 : Si le formulaire est ouvert on désactive le bouton, pour empêcher qu'il s'ouvre plus d'une fois
        if (selectCatJlist.isVisible()) {
            jButton1AjouterCategorie.setEnabled(false);
        } else {
            // OMDB 02.04.2018 : "Affichage" du formulaire.
            selectCatJlist.setVisible(true);


            /* OMDB 11.04.2018 : Désactiver le bouton d'affichage du formulaire, pour empêcher d'ouvrir le même formulaire plusieurs fois.
                on le réactive à la fermeture du formulaire
             */
            jButton1AjouterCategorie.setEnabled(true);
        }

    }//GEN-LAST:event_jButton1AjouterCategorieActionPerformed

    private void jButton1EffacerCategorieActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1EffacerCategorieActionPerformed
        // TODO add your handling code here:
        // OMDB 13.04.2018 : Efface les catégories sélectionnées
        effacerLibelleCategorieBD();

    }//GEN-LAST:event_jButton1EffacerCategorieActionPerformed

    private void jList1CategoriesValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_jList1CategoriesValueChanged
        // TODO add your handling code here:
        if (!evt.getValueIsAdjusting()) {
            jButton1EffacerCategorie.setEnabled(true);
            selectedValuesCategories = (List<String>) jList1Categories.getSelectedValuesList();
            // OMDB 13.04.2018 : Affiche dans une fenêtre jTextArea1SCselected les sous catégories sélectionnées
            String chaineselectedValuesCategories = String.join("\n", selectedValuesCategories);

        } else {
            jButton1EffacerCategorie.setEnabled(false);
        }
    }//GEN-LAST:event_jList1CategoriesValueChanged

    private void requete_id_libelle() {
        try {
            /*  OMDB 08.04.2018 : Requête pour connaître les "id" des libellés,
                on doit les connaître afin de parcourir chaque enregistrement à l'aide 
                des boutons "NEXT", "PREV", "FIRST", "LAST".
                A chaque clic sur un des boutons "NEXT", "PREV", "FIRST", "LAST" on doit "passer" l'id du libellé
             */

            String sql_select_sc_cat = "SELECT id_artistes, nom_artiste FROM T_Artistes T1\n"
                    + "               LEFT JOIN artiste_appartient_label T2 ON T2.fk_Artiste = T1.id_artistes\n"
                    + "               LEFT JOIN T_labels T3 ON T3.id_label = T2.fk_Label\n"
                    + "               INNER JOIN artiste_a_musique T4 ON T4.fk_Artiste = T1.id_artistes\n"
                    + "               INNER JOIN T_Musiques T5 ON T5.id_musiques = T4.fk_Musique\n";

            // OMDB 09.04.2018 : "préparer" la requête (ici sans paramètres) pour la BD.
            pstScCat = ClaConnectionBd.getConnection().prepareStatement(sql_select_sc_cat);
            // OMDB 09.04.2018 : Envoyer la requête à la BD
            rsScCat = pstScCat.executeQuery();


            /*  OMDB 10.04.2018 : ATTENTION : SUBTILITE....
                AFIN DE FERMER LA CONNECTION A LA BD (oConnection.closeConnection() )
                CAR, SI LA CONNECTION N'EST PAS FERMEE IL Y A 100 % DE RISQUE DE PLANTAGE DE L'APPLICATION.
                LES SGBD NE TOLERENT PAS QU'ON SE CONNECTE DE FACON INFINIE AVEC LE MEME UTILISATEUR.
                POUR PROUVER CE QUE J'AFFIRME.... DANS PHPMYADMIN-->ONGLET SQL : SHOW FULL PROCESSLIST LORSQUE 
                CE PROGRAMME JAVA EST LANCE... VOUS VERREZ LA MULTIPLICATION DES SESSIONS AVEC L'UTILISATEUR "ROOT"...
            
                IL FAUT TROUVER UN MOYEN DE SAUVEGARDER LE RESULTAT DE LA REQUETE "sql_select_sc_cat" AVANT DE FERMER LA BASE DE DONNEE.
            
                AVEC JDBC IL EXISTE LA NOTION DE "CachedRowSet" QUI PERMET DE CONSERVER LE RESULTAT DE LA REQUETE 
                EN MEMOIRE ET DE S'Y DEPLACER COMME UN RECORDSET NORMAL.
             */
            factory = RowSetProvider.newFactory();
            rowset = factory.createCachedRowSet();
            // OMDB 10.04.2018 : AFIN DE CONSERVER UN RECORDSET EN MEMOIRE ON UTILISE LA METHODE "populate"
            rowset.populate(rsScCat);

            /* OMDB 09.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
             */
            oConnection.closeConnection();
            // OMDB 10.04.2018 : remplir la SWING CONTROL JLIST avec les valeurs des catégories et des sous catégories. On se place au début (FIRST) du RECORDSET
            remplir_listes_categories_sous_categories("FIRST", rowset);

        } catch (SQLException ex) {
            Logger.getLogger(ClaGestionLibellesCatSousCat.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                /* OMDB 09.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                        AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
                 */
                oConnection.closeConnection();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

    }

    private boolean remplir_listes_categories_sous_categories(String choixCurseur, CachedRowSet rowsetrsScCat) {
        /*
        OMDB 28.04.2018 : Pour afficher des valeurs dans les deux JLIST (CATEGORIE ET SOUS CATEGORIS)
         */

        try {

            /*
                OMDB 08.04.2018 : Les boutons de navigation entre les enregistrements, sont ACTIFS ou PASSIFS.. 
                un petit jeu de logique facile à décrypter hihi !
                Afficher un message de navigation entre les enregistrements.
                Définir la fonction de chaque bouton.
             */
            switch (choixCurseur) {
                case "ACTUAL": {
                    System.out.println("actu");

                    jButton1FirstRecord.setEnabled(true);
                    jButton1PrevRecord.setEnabled(true);
                    jButton1NextRecord.setEnabled(true);
                    jButton1LastRecord.setEnabled(true);
                    rowsetrsScCat.rowUpdated();
                }
                break;
                case "FIRST": {
                    jButton1FirstRecord.setEnabled(false);
                    jButton1PrevRecord.setEnabled(false);
                    System.out.println("first");
                    jButton1NextRecord.setEnabled(true);
                    jButton1LastRecord.setEnabled(true);
                    rowsetrsScCat.first();
                    System.out.println(rowsetrsScCat.first());
                }
                break;
                case "LAST": {

                    jButton1FirstRecord.setEnabled(true);
                    jButton1PrevRecord.setEnabled(true);
                    jButton1NextRecord.setEnabled(true);
                    jButton1LastRecord.setEnabled(true);
                    rowsetrsScCat.last();
                    System.out.println("last");
                    System.out.println(rowsetrsScCat.last());

                }
                break;
                case "NEXT": {

                    jButton1FirstRecord.setEnabled(true);
                    jButton1PrevRecord.setEnabled(true);
                    jLabel2MessageNavigation.setText("");
                    rowsetrsScCat.next();
                    System.out.println("next");
                }
                break;
                case "PREV": {
                    System.out.println("prev");

                    jButton1NextRecord.setEnabled(true);
                    jButton1LastRecord.setEnabled(true);
                    jLabel2MessageNavigation.setText("");
                    rowsetrsScCat.previous();
                }
                break;
                default: // OMDB 08.04.2018 : Pas de cas par "défaut"
                    break;
            }


            /*  
                OMDB 08.04.2018 : La requête "sql_select_sc" récupère les "id_libelle_probleme"
                il suffit de construire une nouvelle requête qui recherche toutes les sous-catégories
                qui correspondent à l'"id_libelle_probleme"
             */
            System.out.println(idLibProb);
            idLibProb = rowsetrsScCat.getString("id_artistes");

            // OMDB 08.04.2018 : Affiche l'id_libelle_probleme
            jLabel1idLibelle.setText(idLibProb);

            String sql_select_cat_where = "SELECT DISTINCT nom_artiste, nom_musique FROM T_Artistes T1\n"
                    + "               LEFT JOIN artiste_appartient_label T2 ON T2.fk_Artiste = T1.id_artistes\n"
                    + "               LEFT JOIN T_labels T3 ON T3.id_label = T2.fk_Label\n"
                    + "               INNER JOIN artiste_a_musique T4 ON T4.fk_Artiste = T1.id_artistes\n"
                    + "               INNER JOIN T_Musiques T5 ON T5.id_musiques = T4.fk_Artiste\n"
                    + "               WHERE id_artistes =" + idLibProb;

            String sql_select_sc_where = "SELECT DISTINCT nom_artiste, id_label, nom_label FROM T_Artistes T1\n"
                    + "               LEFT JOIN artiste_appartient_label T2 ON T2.fk_Artiste = T1.id_artistes\n"
                    + "               LEFT JOIN T_labels T3 ON T3.id_label = T2.fk_Label\n"
                    + "               INNER JOIN artiste_a_musique T4 ON T4.fk_Artiste = T1.id_artistes\n"
                    + "               INNER JOIN T_Musiques T5 ON T5.id_musiques = T4.fk_Artiste\n"
                    + "               WHERE id_artistes =" + idLibProb;

            // OMDB 13.03.2018 : Permet d'afficher des données (CATEGORIES) dans un modèle de liste qu'il est possible de personnaliser.
            DefaultListModel defListModelCat = new DefaultListModel();
            jList1Categories.setModel(defListModelCat);
            // OMDB 13.03.2018 : Permet d'afficher des données (SOUS CATEGORIES) dans un modèle de liste qu'il est possible de personnaliser.
            DefaultListModel defListModelSc = new DefaultListModel();
            jList1SousCategories.setModel(defListModelSc);

            // OMDB 06.04.2018 : "préparer" la requête (ici sans paramètres) pour la BD.
            PreparedStatement pstCat = ClaConnectionBd.getConnection().prepareStatement(sql_select_cat_where);
            // OMDB 06.04.2018 : Envoyer la requête à la BD
            ResultSet rsCat = pstCat.executeQuery();
            // OMDB 08.04.2018 : Parcourir et ajouter à la jLIST les catégories qui correspondent à l'"id_libelle_probleme"
            while (rsCat.next()) {
                // OMDB 04.04.2018 : Afficher le libellé dans une zone de textarea
                jTextArea1Libelle.setText(rsCat.getString("nom_artiste"));
                // OMDB 04.04.2018 : Récupère le NOM DEL CATEGORIE dans l'ensemble des enregistrements (rsCat) grâce à la requête "sql_select_sc_where"
                String nomCategorie = rsCat.getString("nom_musique");
                // OMDB 04.04.2018 : ajoute dans le SWING CONTROL JLIST une valeur de catégorie
                defListModelCat.addElement(nomCategorie);
            }
            /* OMDB 09.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
             */
            oConnection.closeConnection();

            // OMDB 06.04.2018 : "préparer" la requête (ici sans paramètres) pour la BD.
            PreparedStatement pstSc = ClaConnectionBd.getConnection().prepareStatement(sql_select_sc_where);
            // OMDB 06.04.2018 : Envoyer la requête à la BD
            ResultSet rsSc = pstSc.executeQuery();
            // OMDB 08.04.2018 : Parcourir et ajouter à la JLIST les sous catégories qui correspondent à l'"id_libelle_probleme"
            while (rsSc.next()) {
                // OMDB 04.04.2018 : Afficher le libellé dans une zone de textarea
                jTextArea1Libelle.setText(rsSc.getString("nom_artiste"));
                // OMDB 04.04.2018 : Récupère la sous catégorie dans l'ensemble des enregistrements (rsSc) fournis par la requête "sql_select_sc_where"
                String nomSousCategorie = rsSc.getString("nom_label");
                // OMDB 04.04.2018 : ajoute dans le SWING CONTROL JLIST une valeur de sous catégorie
                defListModelSc.addElement(nomSousCategorie);
            }
            /* OMDB 09.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
             */
            oConnection.closeConnection();

            /*
                OMDB 0.04.2018 : Deux tests "peu élégants" pour empêcher une erreur de dépassement du RECORDSET 
                Il est inutile de proposer le bouton "NEXT" alors qu'on se trouve au dernier enregistrement.
                Il est inutile de proposer le bouton "PREV" alors qu'on se trouve au premier enregistrement.
                Afficher un message de navigation dans les enregistrements.
             */
            if (rowsetrsScCat.isFirst()) {
                jButton1FirstRecord.setEnabled(false);
                jButton1PrevRecord.setEnabled(false);
                jLabel2MessageNavigation.setForeground(Color.BLACK);
                jLabel2MessageNavigation.setText("Premier enregistrement");
            } else if (rowsetrsScCat.isLast()) {
                jButton1NextRecord.setEnabled(false);
                jButton1LastRecord.setEnabled(false);
                jLabel2MessageNavigation.setForeground(Color.BLACK);
                jLabel2MessageNavigation.setText("Dernier enregistrement");
            }
            jButton1EffacerSCLibelle.setEnabled(false);
            jButton1EffacerCategorie.setEnabled(false);
            // OMDB 13.03.2018 : Tout s'est bien déroulé ... on lui assigne la valeur TRUE
            return true;
        } catch (Exception e) {
            // OMDB 13.03.2018 : Avertir l'utilisateur d'un sacré problème d'accès aux tables... héhé !!!
            JOptionPane.showMessageDialog(null, "Connection à la BD OK ! \nProblème avec l'accès aux tables de la BD !");
            // OMDB 13.03.2018 : Imprime les erreurs pour pouvoir debugger
            e.printStackTrace();
            // OMDB 13.03.2018 : QUITTE L'APPLICATION
            System.exit(0);
            return false;
        } finally {
            try {
                /* OMDB 09.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                    AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
                 */
                oConnection.closeConnection();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    public boolean effacerLibelleSousCategorieBD() {
        /*
        OMDB 28.04.2018 : Pour effacer une sous-catégories affectée à un libellé
         */
        // OMDB 28.04.2018 : Quelques variables qui sont liées à la sélection des valeurs dans une JLIST
        int idLibelleSousCat = 0;
        int[] selectedIdx;
        selectedIdx = jList1SousCategories.getSelectedIndices();

        // OMDB 15.04.2018 : Requête pour rechercher l'id de la ligne à effacer (id_Libelle_SousCat) dans la table de liaison entre les LIBELLES et les SOUS CATEGORIES
        String sql_idLibelleSousCat = "SELECT id_artiste_appartient_label  FROM artiste_appartient_label WHERE fk_Artiste = ? AND fk_Label = \n"
                + " (SELECT id_label FROM T_labels WHERE nom_label LIKE ?)";

        // OMDB 15.04.2018 : Requête pour EFFACER la ligne (id_artiste_appartient_label) dans la table de liaison entre les LIBELLES et les SOUS CATEGORIES        
        String sql_DeleteidLibelleSousCat = "DELETE FROM artiste_appartient_label WHERE id_artiste_appartient_label = ?";

        try {

            // OMDB 28.04.2018 : l'utilisateur à cliqué sur le bouton d'effacement et rien n'est sélectionné. Affiche un message d'erreur
            if (selectedIdx.length == 0) {
                // OMDB 13.04.2018 : Avertir l'utilisateur qu'il n'a rien sélectonné dans la JLIST
                jLabel2MessageNavigation.setText("Pas de sélection");
                /* OMDB 13.04.2018 : Il ne faut pas que l'utilisateur sélectionne un "EFFACEMENT" 
                    alors que rien n'est sélectionné dans la liste des sous catégories.
                    on désactive le bouton "jButton1EffacerSCLibelle"
                 */
                jButton1EffacerSCLibelle.setEnabled(false);
                JOptionPane.showMessageDialog(null, "PAS DELETE, IL FAUT SéLECTIONNER UN ELEMENT");

            } else {

                int nbValuesSelected = selectedIdx.length;
                int i = 0;
                while (i < nbValuesSelected) {

                    Object nomSousCategorie = jList1SousCategories.getModel().getElementAt(selectedIdx[i]);

                    // OMDB 13.03.2018 : "préparer" la requête (ici avec 2 paramètres) pour la BD.
                    PreparedStatement pstRechidLibelleSousCat = ClaConnectionBd.getConnection().prepareStatement(sql_idLibelleSousCat);
                    // OMDB 13.03.2018 : Passer la valeur au paramètre (défini par ?) dans la requête "sql_idLibelleSousCat"
                    // OMDB 15.04.2018 : Convertir la chaine de caractere en entier
                    pstRechidLibelleSousCat.setInt(1, Integer.parseInt(idLibProb));
                    // OMDB 13.03.2018 : Passer la valeur au paramètre (défini par ?) dans la requête "sql_idLibelleSousCat"
                    pstRechidLibelleSousCat.setString(2, (String) nomSousCategorie);
                    System.out.println("DANS BOUCLE nomSousCategorie " + "i = " + i + " " + (String) nomSousCategorie);
                    // OMDB 15.04.2018 : Envoyer la requête à la BD
                    ResultSet rsRechidLibelleSousCat = pstRechidLibelleSousCat.executeQuery();
                    // OMDB 15.04.2018 : PLACE LE CURSEUR DU RECORDSET SUR LE PEREMIER ELEMENT
                    rsRechidLibelleSousCat.first();

                    // OMDB 15.04.2018 : Récupérer le numéro de la ligne à effacer
                    idLibelleSousCat = rsRechidLibelleSousCat.getInt("id_artiste_appartient_label");
                    // lIGNE INUTILE...JUSTE POUR RASSURER LA PERSONNE QUI EST EN TRAIN DE CODER.....
                    System.out.println("idLibelleSousCat " + idLibelleSousCat);
                    /* OMDB 09.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                        AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
                     */
                    oConnection.closeConnection();

                    // OMDB 15.04.2018 : "préparer" la requête (ici avec 1 paramètre) pour la BD.
                    PreparedStatement pstDeleteidLibelleSousCat = ClaConnectionBd.getConnection().prepareStatement(sql_DeleteidLibelleSousCat);
                    // OMDB 15.04.2018 : Passer la valeur au paramètre (défini par ?) dans la requête "sql_DeleteidLibelleSousCat"
                    pstDeleteidLibelleSousCat.setInt(1, idLibelleSousCat);

                    // OMDB 15.04.2018 : Envoyer la requête d'effacement à la BD
                    int rowsDeleted = pstDeleteidLibelleSousCat.executeUpdate();

                    // OMDB 16.04.2018 : Incrèmente l'indice de boucle de parcours des éléments sélectionnés dans la Jlist.
                    i++;
                    // OMDB 16.04.2018 : ATTENTION MAGIE ET SUBTILITE en programmation JAVA (et autres..)                 
                    //...la désactivation de la Jlist d'abord et sa réactivation plus tard permet de "rafraîchir" son contenu.. "en silence" des listeners
                    jList1SousCategories.setEnabled(false);

                    /* OMDB 09.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                        AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
                     */
                    oConnection.closeConnection();
                }
                JOptionPane.showMessageDialog(null, "DELETE OK");
            }

            // OMDB 04.04.2018 : Recharge les listes avec une requête en lecture des changements de BD
            remplir_listes_categories_sous_categories("ACTUAL", rowset);

            // OMDB 16.04.2018 : ATTENTION MAGIE ET SUBTILITE en programmation JAVA (et autres..)
            // et là voilà sa réactivation de façon à pouvoir rafrâichir la Jlist "en silence" des listeners
            //...la désactivation de la Jlist d'abord et sa réactivation plus tard permet de "rafraîchir" son contenu..    
            jList1SousCategories.setEnabled(true);

            // OMDB 13.04.2018 : Ferme cette fenêtre   
            //this.dispose();
            // OMDB 13.03.2018 : Tout s'est bien déroulé ...donc on lui assigne la valeur TRUE
            return true;
        } catch (Exception e) {
            // OMDB 13.03.2018 : Avertir l'utilisateur d'un sacré problème d'accès aux tables... héhé !!!
            JOptionPane.showMessageDialog(null, "Connection à la BD OK ! \nProblème avec l'accès aux tables de la BD !");
            // OMDB 13.03.2018 : Imprime les erreurs pour pouvoir debugger
            e.printStackTrace();
            // OMDB 13.03.2018 : QUITTE L'APPLICATION
            System.exit(0);
            return false;
        }
    }

    public boolean effacerLibelleCategorieBD() {
        /*
        OMDB 28.04.2018 : Pour effacer une catégories affectée à un libellé
         */
        // OMDB 28.04.2018 : Quelques variables qui sont liées à la sélection des valeurs dans une JLIST        
        int idLibelleCat = 0;
        int[] selectedIdx;
        selectedIdx = jList1Categories.getSelectedIndices();

        // OMDB 24.04.2018 : Requête pour rechercher l'id de la ligne à effacer (id_artiste_a_musique) dans la table de liaison entre les LIBELLES et les CATEGORIES
        String sql_idLibelleCat = "SELECT id_artiste_a_musique FROM artiste_a_musique WHERE fk_Artiste = ? AND fk_Musique = \n"
                + "(SELECT id_musiques FROM T_Musiques WHERE nom_musique COLLATE LIKE ?)";

        // OMDB 24.04.2018 : Requête pour EFFACER la ligne (id_artiste_a_musique) dans la table de liaison entre les LIBELLES et les CATEGORIES        
        String sql_DeleteidLibelleCat = "DELETE FROM artiste_a_musique WHERE id_artiste_a_musique = ?";

        try {
            // OMDB 28.04.2018 : L'utilisateur à cliqué sur le bouton d'effacement et rien n'est sélectionné. Affiche un message d'erreur
            if (selectedIdx.length == 0) {
                // OMDB 24.04.2018 : Avertir l'utilisateur qu'il n'a rien sélectonné
                jLabel2MessageNavigation.setText("Pas de sélection");
                /* OMDB 24.04.2018 : Il ne faut pas que l'utilisateur sélectionne un "EFFACEMENT" 
                    alors que rien n'est sélectionné dans la liste des sous catégories.
                    on désactive le bouton "jButton1EffacerCategorie"
                 */
                jButton1EffacerCategorie.setEnabled(false);
                JOptionPane.showMessageDialog(null, "PAS DELETE, IL FAUT SéLECTIONNER UN ELEMENT");

            } else {

                int nbValuesSelected = selectedIdx.length;
                int i = 0;
                while (i < nbValuesSelected) {

                    Object nomCategorie = jList1Categories.getModel().getElementAt(selectedIdx[i]);

                    // OMDB 24.04.2018 : "préparer" la requête (ici avec 2 paramètres) pour la BD.
                    PreparedStatement pstRechidLibelleCategorie = ClaConnectionBd.getConnection().prepareStatement(sql_idLibelleCat);
                    // OMDB 24.04.2018 : Passer la valeur au paramètre (défini par ?) dans la requête "sql_idLibelleCat"
                    // OMDB 24.04.2018 : Convertir la chaine de caractere en entier
                    pstRechidLibelleCategorie.setInt(1, Integer.parseInt(idLibProb));
                    // OMDB 24.04.2018 : Passer la valeur au paramètre (défini par ?) dans la requête "sql_idLibelleCat"
                    pstRechidLibelleCategorie.setString(2, (String) nomCategorie);
                    System.out.println("DANS BOUCLE nomCategorie " + "i = " + i + " " + (String) nomCategorie);
                    // OMDB 24.04.2018 : Envoyer la requête à la BD
                    ResultSet rsRechidLibelleCategorie = pstRechidLibelleCategorie.executeQuery();
                    // OMDB 24.04.2018 : PLACE LE CURSEUR DU RECORDSET SUR LE PEREMIER ELEMENT
                    rsRechidLibelleCategorie.first();

                    // OMDB 15.04.2018 : Récupérer le numéro de la ligne à effacer
                    idLibelleCat = rsRechidLibelleCategorie.getInt("id_artiste_a_musique");
                    // LIGNE INUTILE...JUSTE POUR RASSURER LA PERSONNE QUI EST EN TRAIN DE CODER.....
                    System.out.println("idLibelleCat " + idLibelleCat);
                    /* OMDB 09.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                        AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
                     */
                    oConnection.closeConnection();

                    // OMDB 24.04.2018 : "préparer" la requête (ici avec 1 paramètre) pour la BD.
                    PreparedStatement pstDeleteidLibelleCat = ClaConnectionBd.getConnection().prepareStatement(sql_DeleteidLibelleCat);
                    // OMDB 24.04.2018 : Passer la valeur au paramètre (défini par ?) dans la requête "sql_DeleteidLibelleCat"
                    pstDeleteidLibelleCat.setInt(1, idLibelleCat);

                    // OMDB 24.04.2018 : Envoyer la requête d'effacement à la BD
                    int rowsDeleted = pstDeleteidLibelleCat.executeUpdate();

                    // OMDB 24.04.2018 : Incrèmente l'indice de boucle de parcours des éléments sélectionnés dans la Jlist.
                    i++;
                    // OMDB 24.04.2018 : ATTENTION MAGIE ET SUBTILITE en programmation JAVA (et autres..)                 
                    //...la désactivation de la Jlist d'abord et sa réactivation plus tard permet de "rafraîchir" son contenu.. "en silence" des listeners
                    jList1Categories.setEnabled(false);

                    /* OMDB 24.04.2018 : ON DOIT FERMER LA CONNECTION A LA BD. 
                        AINSI PAS DE PROBLEMES LIES A LA MULTIPLICATION DES SESSIONS DE L'UTILISATEUR "root"
                     */
                    oConnection.closeConnection();
                }

                JOptionPane.showMessageDialog(null, "DELETE OK");
            }

            // OMDB 04.04.2018 : Recharge les listes avec une requête en lecture des changements de BD
            remplir_listes_categories_sous_categories("ACTUAL", rowset);

            // OMDB 24.04.2018 : ATTENTION MAGIE ET SUBTILITE en programmation JAVA (et autres..)
            // et là voilà sa réactivation de façon à pouvoir rafrâichir la Jlist "en silence" des listeners
            //...la désactivation de la Jlist d'abord et sa réactivation plus tard permet de "rafraîchir" son contenu..    
            jList1Categories.setEnabled(true);

            // OMDB 13.04.2018 : Ferme cette fenêtre   
            //this.dispose();
            // OMDB 24.04.2018 : Tout s'est bien déroulé ...donc on lui assigne la valeur TRUE
            return true;
        } catch (Exception e) {
            // OMDB 24.04.2018 : Avertir l'utilisateur d'un sacré problème d'accès aux tables... héhé !!!
            JOptionPane.showMessageDialog(null, "Connection à la BD OK ! \nProblème avec l'accès aux tables de la BD !");
            // OMDB 24.04.2018 : Imprime les erreurs pour pouvoir debugger
            e.printStackTrace();
            // OMDB 24.04.2018 : QUITTE L'APPLICATION
            System.exit(0);
            return false;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ClaGestionLibellesCatSousCat.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ClaGestionLibellesCatSousCat.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ClaGestionLibellesCatSousCat.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ClaGestionLibellesCatSousCat.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ClaGestionLibellesCatSousCat().setVisible(true);
            }
        });
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1AjouterCategorie;
    private javax.swing.JButton jButton1AjouterSCLibelle;
    private javax.swing.JButton jButton1EffacerCategorie;
    private javax.swing.JButton jButton1EffacerSCLibelle;
    private javax.swing.JButton jButton1Fermer;
    private javax.swing.JButton jButton1FirstRecord;
    private javax.swing.JButton jButton1LastRecord;
    private javax.swing.JButton jButton1NextRecord;
    private javax.swing.JButton jButton1PrevRecord;
    private javax.swing.JLabel jLabel1Categories;
    private javax.swing.JLabel jLabel1_Libelle;
    private javax.swing.JLabel jLabel1_SousCategories;
    private javax.swing.JLabel jLabel1idLibelle;
    private javax.swing.JLabel jLabel2MessageNavigation;
    private javax.swing.JList<String> jList1Categories;
    private javax.swing.JList<String> jList1SousCategories;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea jTextArea1Libelle;
    // End of variables declaration//GEN-END:variables

}
